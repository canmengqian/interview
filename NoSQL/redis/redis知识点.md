# redis知识点

[TOC]

### 数据结构

##### 说一说redis跳跃表（skiplist），压缩列表(zipList)

##### 布隆过滤器

##### LRU，LFU,FIFO缓存实现

##### redis的外部数据结构和内部数据结构？

##### redis是单线程架构为什么还能那么快？

- 纯内存访问
- 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现
- 单线程避免了线程切换和竞态产生的消耗。

##### 什么是慢查询,如何配置和查看慢查询日志?

- slowlog-log-slower-than和slowlog-max-len，Redis使用了一个**列表**来存储慢查询日志

- 慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。
- 慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令

##### Redis持久化机制

- AOF持久化开启且存在AOF文件时，**优先加载AOF**文件

- RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。·RDB方式数据没办法做到**实时**持久化/秒级持久化。因为bgsave每次运行都要执行**fork操作创建子进程**，属于重量级操作，频繁执行成本过高。
- AOF的主要作用是解决了数据持久化的实时性,Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡.
  - always时每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，不建议配置。
  - no，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。
  - **everysec**，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。

##### redis持久化对硬盘,CPU，内存的问题和优化建议

- CPU:子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%.Redis是**CPU密集型**服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。
- **内存**消耗分析。子进程通过fork操作产生，占用内存大小等同于父进程，理论上需要两倍的内存来完成持久化操作，关闭THP
- 硬盘：(1)不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。（2）AOF重写时会消耗大量硬盘IO，可以开启配置no-appendfsync-on-rewrite，默认关闭。表示在AOF重写期间不做fsync操作。 

##### redis全量复制的流程和问题优化

- 复制流程
  1. 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1
  2. 从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内
  3. 从节点接收完主节点传送来的全部数据后会清空自身旧数据
  4. 从节点清空数据后开始加载RDB文件，如果当前节点开启了AOF持久化功能，它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用
- 问题优化
  1. 调整复制积压缓冲区 大小
  2. 使用debug reload命令重新加载RDB并保持运行ID不变，从而有效避免不必要的全量复制
  3. repl-timeout 设置复制超时时间
  4. repl-diskless-sync 使用无盘复制
  5. client-output-buffer-limit  调整客户端缓冲区的流速和大小
  6. slave-serve-stale-data 关闭读一致性
  7. 设置主从的心跳检测频率,防止假死,repl-ping-slave-period，

##### redis主从心跳检测

- 主从节点彼此都有**心跳检测机制**，各自模拟成对方的客户端进行通信，通过client list命令查看复制相关客户端信息，主节点的连接状态为flags=M，从节点连接状态为flags=S。
- 主节点默认**每隔10秒对**从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。
- 从节点在主线程中每隔1秒发送replconf ack{offset}命令，给主节点上报自身当前的**复制偏移量**。

**redis常用的检测指标**

- 慢查询
  - 修改为低算法度的命令
  - 缩减大对象数据或把大对象拆分为多个小对象

- 命令耗时
- 持久化阻塞、
- 连接拒绝
- CPU/内存/网络/磁盘使用过载

##### redis缓冲区类型

- **aof_buf**:所有的写入命令会追加到aof_buf（缓冲区）中。
- **主节点复制客户端缓冲区**:从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性.如果**60秒内缓冲区消耗持续大于64MB或者直接超过256MB**时，主节点将直接关闭复制客户端连接，造成**全量同步失败**
- **普通客户端:**client-output-buffer-limit normal000，Redis并没有对普通客户端的输出缓冲区做限制，一般普通客户端的内存消耗可以忽略不计，但是当有大量慢连接客户端接入时这部分内存消耗就不能忽略了，可以设置maxclients做限制

##### Redis内存删除策略和内存溢出回收策略

- 删除策略
  - 惰性删除
  - 通过定时任务删除

- 溢出策略,内存达到maxmemory上限时会触发相应的溢出控制策略
  1. noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息（error）OOM command not allowed when used memory，此时Redis只响应读操作。
  2. volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。
  3. allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
  4. allkeys-random：随机删除所有键，直到腾出足够空间为止。
  5. volatile-random：随机删除过期键，直到腾出足够空间为止。
  6. volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。

##### 如何合理的优化redis的内存存储？

-  降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。使用序列化工具,在CPU不紧张的情况下,可以考虑压缩数据
- 设置编码类型
- 使用hash+ziplist替代String类型

#### Redis集群模式

##### redis集群模式下如何进行数据分区

​	Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot=CRC16（key）&16383。

##### redis集群创建流程

- 开启集群模式,创建一份集群配置文件，当集群内节点信息发生变化，如**添加节点、节点下线、故障转移**等。节点会自动保存集群状态到配置文件中
- **节点握手**:过Gossip协议彼此通信，达到感知对方的过程
- 分配槽：

##### redis故障转移流程

- 节点下线
  - 主观下线:
    - 集群中**每个节点**都会定期向其他节点发送ping消息，**接收节点**回复pong消息作为响应。如果在**cluster-node-timeout时间内通信一直失败**，则发送节点会认为接收节点存在故障，把**接收节点标记为主观下线**（pfail）状态。**主观下线并不能判断节点的真实状态**
  - 客观下线:
  
  

