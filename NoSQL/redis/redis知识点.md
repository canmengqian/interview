# redis知识点

[TOC]

### 数据结构

##### redis的外部数据结构和内部数据结构？

##### redis是单线程架构为什么还能那么快？

- 纯内存访问
- 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现
- 单线程避免了线程切换和竞态产生的消耗。

##### 什么是慢查询,如何配置和查看慢查询日志?

- slowlog-log-slower-than和slowlog-max-len，Redis使用了一个**列表**来存储慢查询日志

- 慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。
- 慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令

##### Redis持久化机制

- AOF持久化开启且存在AOF文件时，**优先加载AOF**文件

- RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。·RDB方式数据没办法做到**实时**持久化/秒级持久化。因为bgsave每次运行都要执行**fork操作创建子进程**，属于重量级操作，频繁执行成本过高。
- AOF的主要作用是解决了数据持久化的实时性,Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡.
  - always时每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，不建议配置。
  - no，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。
  - **everysec**，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。

##### redis持久化对硬盘,CPU，内存的问题和优化建议

- CPU:子进程负责把进程内的数据分批写入文件，这个过程属于CPU密集操作，通常子进程对单核CPU利用率接近90%.Redis是**CPU密集型**服务，不要做绑定单核CPU操作。由于子进程非常消耗CPU，会和父进程产生单核资源竞争。
- **内存**消耗分析。子进程通过fork操作产生，占用内存大小等同于父进程，理论上需要两倍的内存来完成持久化操作，关闭THP
- 硬盘：(1)不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。（2）AOF重写时会消耗大量硬盘IO，可以开启配置no-appendfsync-on-rewrite，默认关闭。表示在AOF重写期间不做fsync操作。 

##### redis全量复制的流程和问题优化

- 复制流程
  1. 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1
  2. 从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内
  3. 从节点接收完主节点传送来的全部数据后会清空自身旧数据
  4. 从节点清空数据后开始加载RDB文件，如果当前节点开启了AOF持久化功能，它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用

- 问题优化
  1. 调整复制积压缓冲区 大小
  2. 使用debug reload命令重新加载RDB并保持运行ID不变，从而有效避免不必要的全量复制
  3. repl-timeout 设置复制超时时间
  4. repl-diskless-sync 使用无盘复制
  5. client-output-buffer-limit  调整客户端缓冲区的流速和大小



##### redis缓冲区类型

- **aof_buf**:所有的写入命令会追加到aof_buf（缓冲区）中。
- **主节点复制客户端缓冲区**:从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性.如果**60秒内缓冲区消耗持续大于64MB或者直接超过256MB**时，主节点将直接关闭复制客户端连接，造成**全量同步失败**

